---
title: "paxos 抽象理解"
date: "2022-10-25"
aliases: []
---
## 摘要
[[两阶段锁]]+[[WOR]]

## 问题、提示
-  

## 主要笔记
- [博客访问地址](https://maheshba.bitbucket.io/blog/2021/11/15/Paxos.html) 
- [[Paxos]] 使用 [[Quorum 机制]] 实现了 [[WOR]]
	- 这是因为 WOR 的单个 Server 实现，（数据存储在内存或者磁盘）没法持久化数据，必须跨服务器复制才能保证。然而我们对跨服务器的情况也要假设少数服务器会爆炸（比如爆炸导致该服务器数据不可恢复）所以需要 [[Quorum 机制]] 来进行一个多数写入的保证，为了容忍 F 台服务器爆炸，Paxos 需要 2F+1 台服务器。
- 使用[[两阶段锁]]定来实现并发控制
	- 以上问题完成后，引入新的问题：多个客户端同时写入一个 [[Quorum 机制|Quorum]] 的时候，如果不互斥，则最终会在不同的少数服务器上获取到不同的值。（并发写入问题！哈。）
	- 锁的主要问题在于
		1. 可能会遇到[[死锁]]，以[[严格的顺序]]获取锁以防止死锁会增加延迟。
		2. [[分布式系统]]中的锁有一种新的故障模式：客户端在获取锁后可能会[[崩溃]]。
	- [[Paxos]] 通过一种锁窃取形式为这两个问题提供了解决方案。锁有版本或编号；编号较大的锁可以覆盖编号较小的锁。客户将选择一个唯一的锁号；然后尝试用它锁定一个仲裁。如果 acceptor 被解锁，或者被锁定为较小的数字，则获取锁成功；如果接受器被更高的锁号锁定，则失败（在这种情况下，锁定客户端可以使用更高的锁号重试）。锁不是建议性的；写入基于锁号，如果锁被盗，将在接受者处失败。
- _完成写入_：
	- 回想一下，我们假设少数服务器会爆炸。如果客户端锁定了大多数服务器；无法访问剩余的少数；并找到一个值已经写入该多数的单个接受器，它必须假设该值也写入不可访问的少数并确认回一些旧客户端。因此，前进的唯一途径是让新客户端采用该值作为自己的值并将其写入它可以访问的多数。如果存在多个这样的值，则客户端必须选择具有最高关联锁号的值。
- _Livelock_：
	- 如果两个客户端不断地互相窃取锁，显然上面的协议可以活锁。这个问题在理论上是不可能解决的：[[FLP 不可能性]] 结果（早于 Paxos 协议）表明，容错共识不能同时具有活跃性和安全性。Paxos 中的 Livelock 是 FLP 结果的实际示例。
- _不同的锁定/写入仲裁_：
	- 事实证明，您可以锁定一些多数仲裁并写入另一个多数仲裁；两个阶段的法定人数不必相同。（但是对未锁定的接受者的写入必须被解释为先锁定后写入，否则会出现[此错误](https://stackoverflow.com/questions/29880949/contradiction-in-lamports-paxos-made-simple-paper)）。Flexible Paxos 进一步指出，如果可以接受较低的持久性，则写入仲裁不一定必须是多数。
- _预锁定_：
	- 客户端可以在写入值时预先锁定仲裁以避免往返。为了提供对锁定的细粒度控制，我们可以显式地向 WOR 公开一个名为 lock() 的额外 API。如果客户端正在与多个 WOR 交互，而这些 WOR 恰好存在于同一组接受器上，我们可以预先锁定整批 WOR。事实证明，预锁定涵盖了 MultiPaxos 中的关键优化，我们将在后面讨论。
